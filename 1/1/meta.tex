\secrel{\ru{Метапрограммирование}}\secdown

Метапрограммирование\ --- вид программирования, связанный с созданием программ,
которые порождают другие программы как результат своей работы (в частности, на
стадии компиляции их исходного кода), либо программы, которые меняют себя во
время выполнения (самомодифицирующийся код).

\secrel{\ru{Генерация кода}}

При этом подходе код программы не пишется вручную, а создаётся автоматически
программой-генератором на основе другой программы\note{часто на каком-нибудь
специализированном сверхвысокоуровневом DSL-языке} или спецификации требуемого
приложения. Такой подход приобретает смысл, когда у вас вырабываются различные
шаблоны кода, часто достаточно сложные (высокоуровневые парадигмы, выполнение
требований внешних библиотек, стереотипные методы реализации приложений и т.п.).
При этом б\'{о}льшая часть кода теряет содержательный смысл, и становится лишь
механическим выполнением правил реализации/кодирования. В большинстве
практических случаев, при написании типовых приложений, особенно если вы
работаете в одной-двух прикладных областях\note{ERP/бухучет, расчетные
программы, АРМ, САПР, веб-приложения,\ldots}, эта часть становится настолько
значительной, что возникает мысль задавать вручную лишь спецификаторную часть
бизнес-логики, а остальной типовой код добавлять автоматически. Это и
проделывает метапрограмма-генератор.

\secrel{\ru{Мультиплатформенные приложения}}

Проблема поддержки нескольких платформ выполнения для приложений стала особенно
актуальной в последние 5-10 лет с связи с заметным увеличением количества
активно используемых операционных систем, взрывным ростом рынка мобильных
устройств, и развитием облачных технологий. Применение метапрограммирования
позволяет упростить реализацию серверов облачных сервисов и программ-клиентов
для десятков вариантов аппаратных $\times$ программных платформ.

\secrel{Transformational programming (TP)\\
\ru{Трансформаторное программирование}}

A program transformation \ru{Трансформация программы} is any operation \ru{это
любая операция} that takes a computer program \ru{которая берет компьютерную
программы} and generates another program \ru{и генерирует другую программу}.
In many cases \ru{Во многих случаях} the transformed program is required to be
\term{semantically equivalent} to the original \ru{трансформированная программа
должна быть \term{семантически эквивалентна} оригиналу}, relative to a
particular formal semantics \ru{соответственно определенной формальной
семантике} and in fewer cases \ru{или в некоторых случаях} the transformations
result in programs that semantically differ from the original in predictable
ways \ru{результаты трансформации программы семантически предсказуемо отличаются
от оригинала}.\ref{}

While the transformations can be performed manually \ru{В то время как
трансформации могут быть выполнены вручную}, it is often more practical to use a
program transformation system \ru{практичнее использовать систему трансформации
программ} that applies specifications of the required trans\-for\-ma\-tions
\ru{применяющую спецификации заданных трансформаций}. Program transformations
\ru{Трансофрмация программы} may be specified \ru{может быть определена} as
automated procedures \ru{как автоматическая процедура} that modify compiler data
structures \ru{модифицирующая структуры данных компилятора} (e.g. abstract
syntax trees \ru{т.е. абстрактные синтаксические деревья}) representing the
program text \ru{представляющие текст программы}, or may be specified more
conveniently \ru{или может использовать более удобную спецификацию} using
patterns representing parameterized source code text fragments \ru{через шаблоны
представляющие параметризованные фрагменты исходного кода}.

A practical requirement \ru{Практические требования} for source code
trans\-for\-mation systems \ru{к системам трансформации исходного кода} is that
they be able \ru{включают их способность} to effectively process programs
\ru{эффективно обрабатывать программы} written in a programming language
\ru{написанные на языках программирования}. This usually requires integration
\ru{Обычно это приводит к необходимости интеграции} of a full front-end for the
programming language of interest \ru{полного фронтенда интересующего нас языка
программирования}, including source code parsing \ru{включая разбор исходного
кода}, building internal program representations of code structures
\ru{построение внутренних структур представления кода}, the meaning of program
symbols \ru{значения символов программы}, useful static analyses \ru{полезный
статический анализ кода}, and regeneration of valid source code \ru{и
регенерация валидного исходниго кода} from transformed program representations
\ru{из представления трансформированной программы}. The problem of building and
integrating \ru{Проблема построения и интеграции} adequate front ends for
conventional languages \ru{адекватного фронтенда для широко используемых языков}
(\java, \cpp, PHP, \ldots) may be of equal difficulty \ru{может иметь сложность
эквивалентную} as building the program transformation system itself
\ru{построению самой системы трансформации программ} because of the complexity
of such languages \ru{из-за сложности этих языков}. To be widely useful
\ru{Чтобы быть практически полезной}, a transformation system \ru{система
трансформации} must be able to handle many target programming languages
\ru{должна поддерживать множество целевых языков программирования}, and must
provide some means of specifying such front ends \ru{и должна предоставлять
средства для спецификации таких фронтендов}.

A generalisation of semantic equivalence \ru{Обобщение семантической
эквивалентности} is the notion of program refinement \ru{является понятием
\termdef{уточнения}{уточнение программы} программы}: one program is a refinement
of another \ru{программа является уточнением другой программы} if it terminates
on all the initial states \ru{если она завершается на всех начальных состояниях}
for which the original program terminates \ru{на которых завершается
оригинальная программы}, and for each such state \ru{и для каждого из этих
состояний} it is guaranteed to terminate \ru{гарантировано завершение} in a
possible final state for the original program \ru{в возможном оконечном
состоянии оригинальной программы}. In other words \ru{Другими словами}, a
refinement of a program \ru{уточнение программы} is more defined \ru{лучше
определено} and more deterministic \ru{и более детерминистично} than the
original program \ru{чем оригинальная программа}. If two programs are
refinements of each other \ru{Если две программы являются уточнениями друг
друга}, then the programs are equivalent \ru{то программы
\termdef{эквивалентны}{эквивалентная программа}}.

\bigskip
A transformation language \ru{Трансформаторный язык} is a computer language
\ru{это компьютерный язык} designed to transform some input text
\ru{разработанный для преобразования некоторого входного текста} in a certain
formal language \ru{на некотором формальном языке} into a modified output text
\ru{в модифицированный выходной текст} that meets some specific goal
\ru{отвечающий некоторым определенным требованиям}.

Program transformation systems such as \ru{Системы транформации программ такие
как} Stratego/XT, TXL, Tom, DMS, and ASF+SDF all have transformation languages
\ru{включают транформаторные языки} as a major component \ru{как главный
компонент}. The transformation languages for these systems \ru{Трансформаторные
языки для этих систем} are driven by declarative descriptions \ru{определяются
декларативными описаниями} of the structure of the input text \ru{структуры
входного текста} (typically a grammar \ru{обычно это грамматика}), allowing them
to be applied \ru{позволяя им быть примененными} to wide variety of formal
languages and documents \ru{к широкому диапазону формальных языков и
документов}.

Macro languages \ru{Макроязыки} are a kind of transformation languages \ru{это
вид траформаторных языков} to transform a meta language \ru{для преобразования
метаязыка} into specific higher programming language like \ru{в определенный
язык высокого уровня типа} \java, \cpp+, $Fortran$ or into lower-level Assembly
language \ru{или низкоуровневый язык ассемблера}.

In the model-driven engineering technical space \ru{В технических областях
использующих модели}, there are model transformation languages \ru{применяются
языки транформации моделей} (MTLs), that take as input models \ru{которые берут
входную модель} conforming to a given metamodel \ru{удовлетворяющую заданной
метамодели} and produce as output models \ru{и создают выходную модель}
conforming to a different metamodel \ru{соответствующую другой метамодели}.
An example of such a language is the QVT OMG standard \ru{Примером такого языка
является стандарт QVT OMG}.

There are also low-level languages \ru{Также существуют низкоуровневые языки}
such as the Lx family \ru{типа множества языков Lx}\ref{} implemented by the
bootstrapping method \ru{реализованные методом самоприменения}. The L0 language
\ru{Язык L0} may be considered as assembler for transformation languages
\ru{может рассмтариваться как ассемблер для транформаторных языков}. There is
also a high-level graphical language \ru{Также существует высокоуровневый
графический язык} built on upon Lx \ru{построенный на базе языков Lx} called
\ru{который называется} MOLA.\ref{}

There are a number of XML transformation languages \ru{Существует множество
языков транформации XML}. These include \ru{Можно упомянуть} Tritium, XSLT,
XQuery, STX, FXT, XDuce, CDuce, HaXml, XMLambda, and FleXML.

\secrel{\ru{Основные методы реализации}}\secdown

\secrel{Homoiconicity \ru{Гомоиконичность}}

In computer programming \ru{В программировании},
\termdef{homoiconicity}{homoiconicity}
\ru{\termdef{гомоиконичность}{гомоиконичность}}\note{from the Greek words \ru{от
греческих слов} \emph{homo} meaning the same \ru{обозначает \emph{само-}} and
\ru{и} \emph{icon} meaning representation \ru{обозначает \emph{представление}}}\
is a property of some programming languages \ru{это свойство некоторых языков
программирования} in which the program structure is similar to its syntax
\ru{когда структура программы аналогична ее синтаксису}, and therefore \ru{и
таким образом} the program's internal representation \ru{внутреннее представление
программы} can be inferred by reading the text's layout \ru{может быть выведено
через чтение текстового описания}.\ref{}
If a language is homoiconic \ru{Если язык гомоиконичен}, it means that the
language text \ru{это значит что текст программы на этом языке} has the same
structure \ru{имеет ту же структуру} as its abstract syntax tree \ru{что и ее
синтаксическое дерево} (i.e. the AST and the syntax are \term{isomorphic} \ru{то
есть AST и синтаксис \term{изоморфны}}).
This allows all code in the language to be accessed \ru{Это позволяет иметь
доступ ко всему коду на таком языке} and transformed as data \ru{и
трансформировать его как данные}, using the same representation \ru{используя
одно представление}.

In a homoiconic language \ru{В гомоиконичном языке} the primary representation
of programs \ru{первичное представлние программы} is also a \emph{data
structure} \ru{также само является \emph{структурой данных}} in a primitive type
of the language itself \ru{примитивного для этого языка типа}.
This makes metaprogramming easier \ru{Это свойство языка делает
метапрограммирование проще} than in a language without this property \ru{чем в
языке без него}, since code can be treated as data \ru{так как код
рассматривается как данные}:
reflection in the language \ru{интроспекция/рефлексия в языке} (examining the
program's entities at runtime \ru{обработка элементов программы в рантайме})
depends on a single, homogeneous structure \ru{выполняется на простой гомогенной
структуре данных}, and it does not have to handle several different structures
\ru{и не требует поддержки нескольких разнотипных элементов данных} that would
appear in a complex syntax \ru{необходимой при сложном синтаксисе}.
To put that another way \ru{Другими словами}, homoiconicity is where a program's
source code \ru{гомоиконичность это когда исходный код программы} is written as
a basic data structure \ru{является базовой структурой данных} that the
programming language knows how to access \ru{с которой язык умеет работать
непосредственно}.

A typical, commonly cited example \ru{Типичный, широко упоминаемый пример} is
the programming language \ru{это язык программирования} \lisp, which was created
to be easy \ru{который был создан специально} for lists manipulation \ru{для
манипуляции списками} and where the structure is given by \term{S-expressions}
\ru{в котором структура заданная \term{S-выражениями}} that take the form of
nested lists \ru{принимает форму вложенных списков}. \lisp\ programs are written
in the form of lists \ru{Программы на \lisp\ записивыаются в форме списков}; the
result is that the program can access its own functions and procedures while
running \ru{в результате программа может оперировать собственными функциями и
процедурами в процессе выполнения}, and programmatically reprogram itself on the
fly \ru{и репрограммировать себя на лету}. Homoiconic languages typically
include full support of syntactic macros \ru{Гомоиконичные языки обычно включают
полную поддержку синтаксических макросов} allowing the programmer to express
program transformations \ru{позволяющих программисту выражать трансформации
программ} in a concise way \ru{в сжатой форме}. Examples are the programming
languages \ru{Другие примеры таких языков программирования} $Clojure$ (a
contemporary dialect of \ru{современный диалект} \lisp), $Rebol$ and Refal \ru{и
Рефал}.

\secrel{Reflection\\
\ru{Интроспекция}}

\termdef{Интроспекция}{интроспекция}\ --- представление внутренних структур
языка в виде переменных встроенных типов с возможностью доступа к ним из
программы.

Позволяет во время выполнения просматривать, создавать и изменять определения
типов, стек вызовов, обращаться к переменной по имени, получаемому динамически и
пр.

\begin{itemize}[nosep]
  \item 
Пространство имён \verb|System.Reflection| и тип \verb|System.Type| в .NET;
  \item 
классы \verb|Class|, \verb|Method|, \verb|Field| в \java;
  \item 
представление пространств имен и определений типов через встроенные типы данных
в \py;
%   \item 
% стандартные встроенные возможности в $Forth$ по доступу к ресурсам виртуальной
% машины;
  \item 
получение значения и изменение свойств почти любого из объектов в ECMAScript (с
оговорками).
\end{itemize}

\secrel{Интерпретация произвольного кода}

Интерпретация произвольного кода, представленного в виде строки.

Существует естественным образом во множестве интерпретируемых языков (впервые
функция \verb|eval| была реализована в \lisp, а точнее, непосредственно перед
ним, став его первым реализованным интерпретатором).

Компилятор \href{https://ru.wikipedia.org/wiki/Tiny_C_Compiler}{TinyC} позволяет
``на лету'' компилировать и исполнять код на языке \ci, представленный в виде
строки символов. В
\href{https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)}{$Forth$}
предусмотрена интерпретация из строки словом \verb|EVALUATE|.

\secup

\secup
