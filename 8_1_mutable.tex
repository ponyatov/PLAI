\secrel{8.1 Mutable Structures   41}
\secdown
\secrel{8.1.1 A Simple Model of Mutable Structures  41}

Objects are a generalization of structures, as we will soon see \ref{}.
Therefore, fields in objects are a generalization of fields in structures and to
understand mutation, it is mostly (but not entirely! \ref{}) sufficient to
understand mutable objects. To be even more reductionist, we don’t need a
structure to have many fields: a single one will suffice. We call this a box. In
Racket, boxes support just three operations:
\lsts{src/8/1/1.rkt}{rkt}
Thus, box takes a value and wraps it in a mutable container. unbox extracts the
current value inside the container. Finally, set-box! changes the value in the
container, and in a typed language, the new value is expected to be
type-consistent with what was there before. You can thus think of a box as
equivalent to a Java container class with parameterized type, which has a single
member field with a getter and setter: box is the constructor, unbox is the
getter, and set-box! is the setter. (Because there is only one field, its name
is irrelevant.)
\lsts{src/8/1/2.rkt}{rkt}

Because we must sometimes mutate in groups (e.g., removing money from one bank
account and depositing it in another), it is useful to be able to sequence a
group of mutable operations. In Racket, begin lets you write a sequence of
operations; it evaluates them in order and returns the value of the last one.

\Exercise{
Define begin by desugaring into let (and hence into lambda).
}

Even though it is possible to eliminate begin as syntactic sugar, it will prove
extremely useful for understanding how mutation works. Therefore, we will add a
simple, two-term version of sequencing to the core.

\secrel{8.1.2 Scaffolding   42}

First, let’s extend our core language datatype:
\note{This is an excellent illustration of the non-canonical nature of
desguaring. We’ve chosen to add to the core a construct that is certainly not
necessary. If our goal was to shrink the size of the interpreter— perhaps at
some cost to the size of the input program—we would not make this choice. But
our goal in this book is to study pedagogic interpreters, so we choose a larger
language because it is more instructive.}
\lsts{src/8/1/2_1.rkt}{rkt}
Observe that in a setboxC expression, both the box position and its new value
are expressions. The latter is unsurprising, but the former might be. It means
we can write programs such as this in corresponding Racket:
\lsts{src/8/1/2_2.rkt}{rkt}
This evaluates to a list of boxes, the first containing 1 and the second 2.
Observe that the first argument to the first set-box! instruction was (first l),
i.e., an expression that evaluated to a box, rather than just a literal box or
an identifier. This is precisely analogous to languages like Java, where one can
(taking some type liberties) write
\note{Your output may look like '(\#\&1 \#\&2). The \#\& notation is Racket’s
abbreviated syntactic prefix for “box”.}
\lsts{src/8/1/2_3.rkt}{rkt}
Observe that l.get(0) is a compound expression being used to find the
appropriate box, and evaluates to the box object on which set is invoked.

For convenience, we will assume that we have implemented desguaring to provide
us with (a) let and (b) if necessary, more than two terms in a sequence (which
can be desugared into nested sequences). We will also sometimes write
expressions in the original Racket syntax, both for brevity (because the core
language terms can grow quite large and unwieldy) and so that you can run these
same terms in Racket and observe what answers they produce. As this implies, we
are taking the behavior in Racket—which is similar to the behavior in just about
every mainstream language with mutable objects and structures—as the reference
behavior.

\secrel{8.1.3 Interaction with Closures  . . 43}

Consider a simple counter:
\lsts{src/8/1/3_1.rkt}{rkt}
Every time it is invoked, it produces the next integer:
\lst{src/8/1/3_1.log}
Why does this work? It’s because the box is created only once, and bound to n,
and then closed over. All subsequent mutations affect the same box. In contrast,
swapping two lines makes a big difference:
\lsts{src/8/1/3_2.rkt}{rkt}
Observe:
\lst{src/8/1/3_2.log}
In this case, a new box is allocated on every invocation of the function, so the
answer each time is the same (despite the mutation inside the procedure). Our
implementation of boxes should be certain to preserve this distinction.

The examples above hint at an implementation necessity. Clearly, whatever the
environment closes over in new-loc must refer to the same box each time. Yet
something also needs to make sure that the value in that box is different each
time! Look at it more carefully: it must be lexically the same, but dynamically
different. This distinction will be at the heart of our implementation.

\secrel{8.1.4 Understanding the Interpretation of Boxes . . 44}
\secrel{8.1.5 Can the Environment Help?  46}
\secrel{8.1.6 Introducing the Store  . 48}
\secrel{8.1.7 Interpreting Boxes  . . 49}
\secrel{8.1.8 The Bigger Picture  . . 54}
\secup
