\secrel{8.1 Mutable Structures   41}
\secdown
\secrel{8.1.1 A Simple Model of Mutable Structures  41}

Objects are a generalization of structures, as we will soon see \ref{}.
Therefore, fields in objects are a generalization of fields in structures and to
understand mutation, it is mostly (but not entirely! \ref{}) sufficient to
understand mutable objects. To be even more reductionist, we don’t need a
structure to have many fields: a single one will suffice. We call this a box. In
Racket, boxes support just three operations:
\lsts{src/8/1/1.rkt}{rkt}
Thus, box takes a value and wraps it in a mutable container. unbox extracts the
current value inside the container. Finally, set-box! changes the value in the
container, and in a typed language, the new value is expected to be
type-consistent with what was there before. You can thus think of a box as
equivalent to a Java container class with parameterized type, which has a single
member field with a getter and setter: box is the constructor, unbox is the
getter, and set-box! is the setter. (Because there is only one field, its name
is irrelevant.)
\lsts{src/8/1/2.rkt}{rkt}

Because we must sometimes mutate in groups (e.g., removing money from one bank
account and depositing it in another), it is useful to be able to sequence a
group of mutable operations. In Racket, begin lets you write a sequence of
operations; it evaluates them in order and returns the value of the last one.

\Exercise{
Define begin by desugaring into let (and hence into lambda).
}

Even though it is possible to eliminate begin as syntactic sugar, it will prove
extremely useful for understanding how mutation works. Therefore, we will add a
simple, two-term version of sequencing to the core.

\secrel{8.1.2 Scaffolding   42}

First, let’s extend our core language datatype:
\note{This is an excellent illustration of the non-canonical nature of
desguaring. We’ve chosen to add to the core a construct that is certainly not
necessary. If our goal was to shrink the size of the interpreter— perhaps at
some cost to the size of the input program—we would not make this choice. But
our goal in this book is to study pedagogic interpreters, so we choose a larger
language because it is more instructive.}
\lsts{src/8/1/2_1.rkt}{rkt}
Observe that in a setboxC expression, both the box position and its new value
are expressions. The latter is unsurprising, but the former might be. It means
we can write programs such as this in corresponding Racket:
\lsts{src/8/1/2_2.rkt}{rkt}
This evaluates to a list of boxes, the first containing 1 and the second 2.
Observe that the first argument to the first set-box! instruction was (first l),
i.e., an expression that evaluated to a box, rather than just a literal box or
an identifier. This is precisely analogous to languages like Java, where one can
(taking some type liberties) write
\note{Your output may look like '(\#\&1 \#\&2). The \#\& notation is Racket’s
abbreviated syntactic prefix for “box”.}
\lsts{src/8/1/2_3.rkt}{rkt}
Observe that l.get(0) is a compound expression being used to find the
appropriate box, and evaluates to the box object on which set is invoked.

For convenience, we will assume that we have implemented desguaring to provide
us with (a) let and (b) if necessary, more than two terms in a sequence (which
can be desugared into nested sequences). We will also sometimes write
expressions in the original Racket syntax, both for brevity (because the core
language terms can grow quite large and unwieldy) and so that you can run these
same terms in Racket and observe what answers they produce. As this implies, we
are taking the behavior in Racket—which is similar to the behavior in just about
every mainstream language with mutable objects and structures—as the reference
behavior.

\secrel{8.1.3 Interaction with Closures  . . 43}

Consider a simple counter:
\lsts{src/8/1/3_1.rkt}{rkt}
Every time it is invoked, it produces the next integer:
\lst{src/8/1/3_1.log}
Why does this work? It’s because the box is created only once, and bound to n,
and then closed over. All subsequent mutations affect the same box. In contrast,
swapping two lines makes a big difference:
\lsts{src/8/1/3_2.rkt}{rkt}
Observe:
\lst{src/8/1/3_2.log}
In this case, a new box is allocated on every invocation of the function, so the
answer each time is the same (despite the mutation inside the procedure). Our
implementation of boxes should be certain to preserve this distinction.

The examples above hint at an implementation necessity. Clearly, whatever the
environment closes over in new-loc must refer to the same box each time. Yet
something also needs to make sure that the value in that box is different each
time! Look at it more carefully: it must be lexically the same, but dynamically
different. This distinction will be at the heart of our implementation.

\secrel{8.1.4 Understanding the Interpretation of Boxes . . 44}

Let’s begin by reproducing our current interpreter:
\lst{src/8/1/4_1.rkt}
Because we’ve introduced a new kind of value, the box, we have to update the set
of values:
\lst{src/8/1/4_2.rkt}
Two of these cases should be easy. When we’re given a box expression, we simply
evaluate it and return it wrapped in a boxV:
\lst{src/8/1/4_3.rkt}
Similarly, extracting a value from a box is easy:
\lst{src/8/1/4_4.rkt}

By now, you should be constructing a healthy set of test cases to make sure
these behave as you’d expect.

Of course, we haven’t done any hard work yet. All the interesting behavior is,
presumably, hidden in the treatment of setboxC. It may therefore surprise you
that we’re going to look at seqC first instead (and you’ll see why we included
it in the core).

Let’s take the most natural implementation of a sequence of two instructions:
\lst{src/8/1/4_5.rkt}

That is, we evaluate the first term, then the second, and return the result of
the second.

You should immediately spot something troubling. We bound the result of
evaluating the first term, but didn’t subsequently do anything with it. That’s
okay: presumably the first term contained a mutation expression of some sort,
and its value is uninteresting (indeed, note that set-box! returns a void
value). Thus, another implementation might be this:
\lst{src/8/1/4_6.rkt}

Not only is this slightly dissatisfying in that it just uses the analogous
Racket sequencing construct, it still can’t possibly be right! This can only
work only if the result of the mutation is being stored somewhere. But because
our interpreter only computes values, and does not perform any mutation itself,
any mutations in (interp b1 env) are completely lost. This is obviously not what
we want.

\secrel{8.1.5 Can the Environment Help?  46}

Here is another example that can help:
\lst{src/8/1/5_1.rkt}
In Racket, this evaluates to 2.

\Exercise{
Represent this expression in ExprC.
}

Let’s consider the evaluation of the inner sequence. In both cases, the
expression (the representation of (set-box! ...)) is exactly identical. Yet
something is changing underneath, because these cause the value of the box to go
from 0 to 2! We can “see” this even more clearly if instead we evaluate
\lst{src/8/1/5_2.rkt}
which evaluates to 3. Here, the two calls to interp in the rule for addition are
sending exactly the same textual expression in both cases. Yet somehow the
effects from the left branch of the addition are being felt in the right branch,
and we must rule out spukhafte Fernwirkung.

If the interpreter is being given precisely the same expression, how can it
possibly avoid producing precisely the same answer? The most obvious way is if
the interpreter’s other parameter, the environment were somehow different. As of
now the exact same environment is sent to both both branches of the sequence and
both arms of the addition, so our interpreter—which produces the same output
every time on a given input—cannot possibly produce the answers we want.

Here is what we know so far:
\begin{enumerate}[nosep]
  \item 
We must somehow make sure the interpreter is fed different arguments on calls
that are expected to potentially produce different results.
  \item 
We must return from the interpreter some record of the mutations made when
evaluating its argument expression.
\end{enumerate}

Because the expression is what it is, the first point suggests that we might try
to use the environment to reflect the differences between invocations. In turn,
the second point suggests that each invocation of the interpreter should also
return the environment, so it can be passed to the next invocation. Roughly,
then, the type of the interpreter might become:
\lst{src/8/1/5_3.rkt}
That is, the interpreter consumes an expression and environment; it evaluates in
that environment, updating it as it proceeds; when the expression is done
evaluating, the interpreter returns the answer (as it did before), along with an
updated environment, which in turn is sent to the next invocation of the
interpreter. And the treatment of setboxC would somehow impact the environment
to reflect the mutation.

Before we dive into the implementation, however, we should consider the
consequences of such a change. The environment already serves an important
purpose: it holds deferred substitutions. In that respect, it already has a
precise semantics—given by substitution—and we must be careful to not alter
that. One consequence of its tie to substitution is that it is also the
repository of lexical scope information. If we were to allow the extended
environment escape from one branch of addition and be used in the other, for
instance, consider the impact on the equivalent of the following program:
\lst{src/8/1/5_4.rkt}
It should be evident that this program has an error: b in the right branch of
the addition is unbound (the scope of the b in the left branch ends with the
closing of the let—if this is not evident, desugar the above expression to use
functions). But the extended environment at the end of interpreting the let
clearly has b bound in it.
\Exercise{
Work out the above problem in detail and make sure you understand it.
}

You could try various other related proposals, but they are likely to all have
similar failings. For instance, you may decide that, because the problem has to
do with additional bindings in the environment, you will instead remove all
added bindings in the returned environment. Sounds attractive? Did you remember
we have closures?
\Exercise{
Consider the representation of the following program:
\lst{src/8/1/5_5.rkt}
What problems does this example cause?
}

Rather, we should note that while the constraints described above are all valid,
the solution we proposed is not the only one. What we require are the two
conditions enumerated above; observe that neither one actually requires the
environment to be the responsible agent. Indeed, it is quite evident that the
environment cannot be the principal agent.

\secrel{8.1.6 Introducing the Store  . 48}
\secrel{8.1.7 Interpreting Boxes  . . 49}
\secrel{8.1.8 The Bigger Picture  . . 54}
\secup
