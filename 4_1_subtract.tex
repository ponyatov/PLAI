\secrel{4.1 Extension: Binary Subtraction \ru{Раширение: бинарное вычитание}}

First, we’ll add subtraction. Because our language already has numbers,
addition, and multiplication, it’s easy to define subtraction: $a-b=a+-1\times
b$.

Okay, that was easy\,! But now we should turn this into concrete code. To do so,
we face a decision: where does this new subtraction operator reside\,? It is
tempting, and perhaps seems natural, to just add one more rule to our existing
\class{ArithC}\ datatype.

\DoNow{
What are the negative consequences of modifying \class{ArithC}\,?
}

This creates a few problems. The first, obvious, one is that we now have to
modify all programs that process \class{ArithC}. So far that’s only our
interpreter, which is pretty simple, but in a more complex implementation, that
could already be a concern. Second, we were trying to add new constructs that we
can define in terms of existing ones; it feels slightly self-defeating to do
this in a way that isn’t modular. Third, and most subtly, there’s something
\emph{conceptually} wrong about modifying \class{ArithC}. That’s because
\class{ArithC} represents our \emph{core} language. In contrast, subtraction and
other additions represent our user-facing, surface language. It’s wise to record conceptually different ideas
in distinct datatypes, rather than shoehorn them into one. The separation can
look a little unwieldy sometimes, but it makes the program much easier for
future developers to read and maintain. Besides, for different purposes you
might want to layer on different extensions, and separating the core from the
surface enables that.

Therefore, we’ll define a new datatype to reflect our intended surface syntax
terms:
\lstx{\class{ArithS}}{src/4/p17_1.rkt}{rkt}
This looks almost exactly like \class{ArithC}, other than the added case, which
follows the familiar recursive pattern.

Given this datatype, we should do two things. First, we should modify our parser
to also parse\ --- expressions, and always construct ArithS terms\note{rather
than any \class{ArithC} ones}. Second, we should implement a desugar function
that translates \class{ArithS} values into \class{ArithC} ones.

Let’s write the obvious part of desugar:
\lstx{<desugar>::=}{src/4/p17_2.rkt}{rkt}
Now let’s convert the mathematical description of subtraction above into code:
\lstx{<bminusS-case>::=}{src/4/p18_1.rkt}{rkt}

\DoNow{
It’s a common mistake to forget the recursive calls to desugar on $l$ and
$r$. What happens when you forget them\,? Try for yourself and see.
}