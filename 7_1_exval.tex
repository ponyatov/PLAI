\secrel{7.1 Functions as Expressions and Values  32}

Let’s first define the core language to include function definitions:
\lsts{src/7/7_1_1.rkt}{rkt}

For now, we’ll simply copy function definitions into the expression language.
We’re free to change this if necessary as we go along, but for now it at least
allows us to reuse our existing test cases.
\lsts{src/7/7_1_2.rkt}{rkt}

We also need to determine what an application looks like. What goes in the
function position of an application? We want to allow an entire function
definition, not just its name. Because we’ve lumped function definitions in with
all other expressions, let’s allow an arbitrary expression here, but with the
understanding that we want only function definition expressions:
\note{We might consider more refined datatypes that split function definitions
apart from other kinds of expressions. This amounts to trying to classify
different kinds of expressions, which we will return to when we study types.
\ref{}}
\lsts{src/7/7_1_3.rkt}{rkt}

With this definition of application, we no longer have to look up functions by name,
so the interpreter can get rid of the list of function definitions. If we need it we can
restore it later, but for now let’s just explore what happens with function definitions are
written at the point of application: so-called immediate functions.

Now let’s tackle interp. We need to add a case to the interpreter for function
definitions, and this is a good candidate:
\lsts{src/7/7_1_4.rkt}{rkt}

\DoNow{
What happens when you add this?
}
Immediately, we see that we have a problem: the interpreter no longer always
returns numbers, so we have a type error.

We’ve alluded periodically to the answers computed by the interpreter, but never
bothered gracing these with their own type. It’s time to do so now.
\lsts{src/7/7_1_5.rkt}{rkt}

We’re using the suffix of V to stand for values, i.e., the result of evaluation.
The pieces of a funV will be precisely those of a fdC: the latter is input, the
former is output. By keeping them distinct we allow each one to evolve
independently as needed.

Now we must rewrite the interpreter. Let’s start with its type:
\lsts{src/7/7_1_6.rkt}{rkt}

This change naturally forces corresponding type changes to the Binding datatype
and to lookup.

\Exercise{
Modify Binding and lookup, appropriately.
}
\lsts{src/7/7_1_7.rkt}{rkt}

Clearly, numeric answers need to be wrapped in the appropriate numeric answer
constructor. Identifier lookup is unchanged. We have to slightly modify addition
and multiplication to deal with the fact that the interpreter returns Values,
not numbers:
\lsts{src/7/7_1_8.rkt}{rkt}

It’s worth examining the definition of one of these helper functions:
\lsts{src/7/7_1_9.rkt}{rkt}