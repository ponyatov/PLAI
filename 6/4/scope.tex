\secrel{Scope\\\ru{Область видимости}}

The broken environment interpreter above \ru{Сломанный интерпретатор на средах
выше} implements what is known as \termdef{dynamic scope}{dynamic scope}
\ru{реализовывал то что называется \termdef{динамическая область
видимости}{динамическая область видимости}}. This means \ru{Это значит что} the
environment accumulates bindings as the program executes \ru{среда аккумулирует
связки в процессе выполнения программы}. As a result \ru{В результате}, whether
an identifier is even bound \ru{определение того является ли идентификатор
связанным} depends on the history of program execution \ru{зависит от истории
исполнения программы}. We should regard this unambiguously \ru{Мы должны
рассматривать это} as a flaw of programming language design \ru{как недостаток
дизайна языка программирования}. It adversely affects all tools \ru{Это
отрицательно влияет на все инструменты} that read and process programs
\ru{которые читают и обрабатывают программы}: compilers, IDEs, and humans
\ru{компиляторы, IDE и человеки}.

In contrast \ru{Наоборот}, substitution \ru{подстановка}\ --- and environments,
done correctly \ru{правильно реализованные среды}\ --- give us \termdef{lexical
scope}{lexical scope} or \termdef{static scope}{static scope} \ru{дают нам
\termdef{лексеческую}{лексическая область видимости} или
\termdef{статическую}{статическая область видимости} области видимости}.
``Lexical'' in this context means \ru{``Лексическая'' в этом контексте значит}
``as determined from the source program'' \ru{``определенная из исходного кода
программы''}, while ``static'' in computer science means \ru{в то время как
``статическая'' в информатике значит} ``without running the program'' \ru{``без
запуска программы''}, so these are appealing to the same intuition \ru{эти
названия следуют той же идее}. When we examine an identifier \ru{Когда мы
встречаем идентификатор}, we want to know two things \ru{мы хотим знать две
вещи}: (1) Is it bound \ru{Связан ли он}\,? (2) If so, where \ru{и если связан,
то где}\,? By “where” we mean \ru{``Где'' мы имеем в виду}: if there are
multiple bindings for the same name \ru{если существуют множественные связки для
одного имени}, which one governs this identifier \ru{какая из них контролирует
этот идентификатор}\,? Put differently \ru{Другими словами}, which one’s
substitution \ru{какая из подстановок} will give a value to this identifier
\ru{даст значение для этого идентификатора}\,? In general \ru{В общем}, these
questions cannot be answered statically \ru{на эти вопросы нельзя дать
статические ответы} in a dynamically-scoped language \ru{в языке с динамическими
областями видимости}: so your IDE \ru{так что ваша IDE}, for instance
\ru{например}, cannot overlay arrows to show you this information \ru{не может
расставить стрелки чтобы показать эту информацию} (as Dr\racket\ does \ru{как
это делает Dr\racket}).
\note{A different way to think about it is that in a dynamically-scoped
language, the answer to these questions is the same for all identifiers, and it
simply refers to the dynamic environment. In other words, it provides no useful
information.}
\note{\ru{Другой способ думать об этом для языка с динамической областью
видимости\ --- ответ на вопрос один для всех идентификаторов: так как указано
в динамической среде. То есть он не дает никакой полезной информации.}}
Thus \ru{Таким образом}, even though the rules of scope become more complex
\ru{по мере того как правила области видимости становятся сложнее} as the space
of names becomes richer \ru{и пространство типов имен становится богаче} (e.g.,
objects, threads, etc. \ru{например объекты, нити, и т.д.}), we should always
strive to preserve the spirit of static scoping \ru{мы всегда должны стремиться
сохранить дух статической области видимости}.

\secdown
\secrel{How Bad Is It\,?\\\ru{Насколько это плохо\,?}}

You might look at our running example \ru{Вы можете посмотреть на наш рабочий
пример} and wonder whether we’re creating a tempest in a teapot \ru{и удивиться
почему мы создаем бурю в стакане воды}. In return \ru{В свою очередь}, you
should consider two situations \ru{мы должны рассмотреть две ситуации}:
\begin{enumerate}

\item To understand the binding structure of your program \ru{Для понимания
структуры привязок в вашей программе}, you may need to look \emph{at the whole
program} \ru{вам потребуется рассматривать \emph{целиком всю программу}}. No
matter how much you’ve decomposed your program \ru{Не важно что вы разбили
программу} into small, understandable fragments \ru{на маленькие понятные
фрагменты}, it doesn’t matter if you have a free identifier anywhere \ru{не
важно если у вас есть где-то свободные идентификаторы}.

\item Understanding the binding structure \ru{Понимание структуры привязок} is
not only a function of the size of the program \ru{не только функция от размера
программы} but also of the complexity of its control flow \ru{но и от сложности
ее структур управления}. Imagine an interactive program with numerous callbacks
\ru{Представьте интерактивную программу со множеством обработчиков событий};
you’d have to track through every one of them \ru{вы должны отслеживать ее
поведение при срабатывании обработчиков в любом порядке}, too, to know which
binding governs an identifier \ru{чтобы понять как срабатывают привязки
идентификаторов}.

\end{enumerate}

Need a little more of a nudge \ru{Хотите еще пендаль}\,? Let’s replace the
expression of our example program with this one \ru{Давайте заменим выражение
в нашей программе-примере вот этим}:
\lsts{6/4/1.rkt}{rkt}
Suppose \ru{Предположим} \verb|moon-visible?| is a function \ru{это функция}
that presumably evaluates to \ru{которая предположительно вычисляется в}
\verb|false| on new-moon nights \ru{в ночи новолуния}, and \ru{и} \verb|true| at
other times \ru{в другое время}. Then \ru{Так что}, this program will evaluate
to an answer \ru{эта программа будет вычисляться до значения} except on new-moon
nights \ru{в зависимости от фазы луны}, when it will fail with an unbound
identifier error \ru{иногда она будет падать в ошибку несвязанного
идентификатора}.

\Exercise{
What happens on cloudy nights\,?\\\ru{Что случиться в облачную ночь}\,?
}

\secrel{6.4.2 The Top-Level Scope  . 31}

Matters become more complex when we contemplate top-level definitions in many
languages. For instance, some versions of Scheme (which is a paragon of lexical
scoping) allow you to write this:
\lsts{6/4/2.rkt}{rkt}
which seems to pretty clearly suggest where the y in the body of f will come
from, except:
\lsts{6/4/3.rkt}{rkt}
is legal and (f 10) produces 12. Wait, you might think, always take the last
one! But:
\lsts{6/4/4.rkt}{rkt}

Here, z is bound to the first value of y whereas the inner y is bound to the
second value. There is actually a valid explanation of this behavior in terms of
lexical scope, but it can become convoluted, and perhaps a more sensible option
is to prevent such redefinition. Racket does precisely this, thereby offering
the convenience of a top-level without its pain.
\note{Most “scripting” languages exhibit similar problems. As a result, on the
Web you will find enormous confusion about whether a certain language is
statically- or dynamically-scoped, when in fact readers are comparing behavior
inside functions (often static) against the top-level (usually dynamic).
Beware!}

\secup
