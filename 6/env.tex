\secrel{From Substitution to Environments\\
\ru{От подстановки к ср\'{е}дам}}\secdown

Though we have a working definition of functions \ru{Теперь, когда мы имеем
работающее определение функций}, you may feel a slight unease about it \ru{вы
можете почувствовать легкое беспокойство по этому поводу}. When the interpreter
sees an identifier \ru{Когда интерпретатор видит идентификатор}, you might have
had a sense \ru{вы возможно имеете ощущение} that it needs to \ru{что он должен}
``look it up'' \ru{``поискать`` его}. Not only did it not look up anything
\ru{Мало того, что он ничего не ищет}, we defined its behavior to be an error
\ru{мы определили его поведение с заложенной ошибкой}\,! While absolutely
correct \ru{Это совершенно точно}, this is also a little surprising \ru{и при
этом немного удивительно}. More importantly, \ru{Важнее то, что} we write
interpreters to \emph{understand} and \emph{explain} languages \ru{мы пишем
интерпретаторы для \emph{понимания} и \emph{объяснения} языков}, and this
implementation might strike you as not doing that \ru{и эта реализация может
показаться вам не делающей это}, because it doesn’t match our intuition
\ru{потому что она не соответствует нашим интуитивным предположениям}.

There’s another difficulty with using substitution \ru{Также есть другая
сложность с использованием подстановки}, which is the number of times we
traverse the source program \ru{это количество проходов по программе}.
It would be nice to have \ru{Было бы хорошо} to traverse only those parts of the
program \ru{проходить только по тем частям программы} that are actually
evaluated \ru{которые реально вычисляются}, and then, only when necessary \ru{и
притом только когда это необходимо}. But substitution traverses everything
\ru{Но подстановка обходит все}\ --- unvisited branches of conditionals, for
instance \ru{например неиспользуемые ветви условий}\ --- and forces the program
to be traversed \ru{и заставляет обходить программу дважды:} once for
substitution \ru{один раз для подстановки} and once again for interpretation
\ru{и еще раз для интерпретации}.

\Exercise{
Does substitution have implications for the time complexity of evaluation\,?\\
\ru{Какие последствия имеет подстановка с точки зрения временн\'{о}й сложности
вычисления\,?}
}

There’s yet another problem with substitution \ru{И есть еще одна проблема с
подстановкой}, which is that it is defined in terms of representations of the
program source \ru{она определена в терминах представления исходного кода
программы}. Obviously, our interpreter has and needs access to the source
\ru{Очевидно что наш интерпретатор имеет и принципиально должен иметь доступ к
исходному коду}, to interpret it \ru{для его интерпретации}. However, other
implementations \ru{В то же время, другие реализации языка}\ --- such as
compilers \ru{такие как компиляторы}\ --- have no need to store it for that
purpose \ru{не требуют хранить исходный код для этих целей}. It would be nice to
employ a mechanism \ru{Было бы хорошо реализовать механизм} that is more
portable across implementation strategies \ru{более переносимый между
стратегиями реализации}.
\note{Compilers might store versions of or information about the source for
other reasons, such as reporting runtime errors, and JITs may need it to
re-compile on demand.}
\note{\ru{Компиляторы могут хранить версии или информацию об исходном коде для
других целей, таких как вывод отчетов об ошибках времени выполнения, или эта
информация может использоваться JIT-компилятором для рекомпиляции по
требованию.}}

\input{6/1/intro}
\input{6/2/interp}
\input{6/3/defer}
\input{6/4/scope}
\input{6/5/expose}
\secup

