\secrel{6 From Substitution to Environments 25}\secdown

Though we have a working definition of functions, you may feel a slight unease
about it. When the interpreter sees an identifier, you might have had a sense
that it needs to “look it up”. Not only did it not look up anything, we defined
its behavior to be an error! While absolutely correct, this is also a little
surprising. More importantly, we write interpreters to understand and explain
languages, and this implementation might strike you as not doing that, because
it doesn’t match our intuition.

There’s another difficulty with using substitution, which is the number of times
we traverse the source program. It would be nice to have to traverse only those
parts of the program that are actually evaluated, and then, only when necessary.
But substitution traverses everything—unvisited branches of conditionals, for
instance—and forces the program to be traversed once for substitution and once
again for interpretation.

\Exercise{
Does substitution have implications for the time complexity of evaluation?
}

There’s yet another problem with substitution, which is that it is defined in
terms of representations of the program source. Obviously, our interpreter has
and needs access to the source, to interpret it. However, other
implementations—such as compilers— have no need to store it for that purpose.
It would be nice to employ a mechanism that is more portable across
implementation strategies.
\note{Compilers might store versions of or information about the source for
other reasons, such as reporting runtime errors, and JITs may need it to
re-compile on demand.}

\input{6/1/intro}
\input{6/2/interp}
\input{6/3/defer}
\input{6/4/scope}
\input{6/5/expose}
\secup

