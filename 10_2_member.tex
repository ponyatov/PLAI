\secrel{10.2 Member Access Design Space  75}

We already have two orthogonal dimensions when it comes to the treatment of member
names. One dimension is whether the name is provided statically or computed, and the
other is whether the set of names is fixed or variable:
\begin{tabular}{|p{0.3\linewidth}|p{0.3\linewidth}|p{0.3\linewidth}|}
\hline
& Name is Static & Name is Computed \\
\hline
Fixed Set & As in base Java. & As in Java \\
of Members && with reflection \\ &&to compute the name.\\
\hline
Variable Set& Difficult to envision & Most
scripting \\
of Members & (what use & languages. \\ & would it be?). &\\ 
\hline
\end{tabular}
Only one case does not quite make sense: if we force the developer to specify
the member name in the source file explicitly, then no new members would be
accessible (and some accesses to previously-existing, but deleted, members would
fail). All other points in this design space have, however, been explored by
languages.

The lower-right quadrant corresponds closely with languages that use hash-tables
to represent objects. Then the name is simply the index into the hash-table.
Some languages carry this to an extreme and use the same representation even for
numeric indices, thereby (for instance) conflating objects with dictionaries and
even arrays. Even when the object only handles “member names”, this style of
object creates significant difficulty for type-checking \ref{}\ and is hence not
automatically desirable.

Therefore, in the rest of this section, we will stick with “traditional” objects
that have a fixed set of names and even static member name references (the
top-left quadrant). Even then, we will find there is much, much more to study.
