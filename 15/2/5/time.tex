\secrel{15.2.5 Types, Time, and Space  . . 144}

It is evident that types already bestow a performance benefit in safe languages.
That is because the checks that would have been performed at run-time—e.g., +
checking that both its arguments are indeed numbers—are now performed
statically. In a typed language, an annotation like : number already answers the
question of whether or not something is of a particular a type; there is nothing
to ask at run-time. As a result, these type-level predicates can (and need to)
disappear entirely, and with them any need to use them in programs.

This is at some cost to the developer, who must convince the static type system
that their program does not induce type errors; due to the limitations of
decidability, even programs that might have run without error might run afoul of
the type system. Nevertheless, for programs that meet this requirement, types
provide a notable execution time saving.

Now let’s discuss space. Until now, the language run-time system has needed to
store information attached to every value indicating what its type is. This is
how it can implement type-level predicates such as number?, which may be used
both by developers and by primitives. If those predicates disappear, so does the
space needed to hold information to implement them. Thus, type-tags are no
longer necessary.
\note{They would, however, still be needed by the garbage collector, though
other representations such as BIBOP can greatly reduce their space impact.}

The type-like predicates still left are those for variants: BTmt? and BTnd?, in
the example above. These must indeed be applied at run-time. For instance, as we
have noted, selectors like BTnd-n must perform this check. Of course, some more
optimizations are possible. Consider the code generated by desugaring the
pattern-matcher: there is no need for the three selectors to implement this
check, because control could only have gotten to them after BTnd? returned a
true vlaue. Thus, the run-time system could provide just the desugaring level
access to special unsafe primitives that do not perform the check, resulting in
generated code such as this:
\lsts{15/2/5/1.rkt}{rkt}

The net result, however, is that the run-time representation must still store
enough information to accurately answer these questions. However, previously it
needed to use enough bits to record every possible type (and variant). Now,
because the types have been statically segregated, for a type with no variants
(e.g., there is only one kind of string), there is no need to store any variant
information at all; that means the run-time system can use all available bits to
store actual dynamic values.

In contrast, when variants are present, the run-time system must sacrifice bits
to distinguish between the variants, but the number of variants within a type is
obviously far smaller than the number of variants and types across all types. In
the BTnum example above, there are only two variants, so the run-time system
needs to use only one bit to record which variant of BTnum a value represents.

Observe, in particular, that the type system’s segregation prevents confusion.
If there are two different datatypes that each have two variants, in the untyped
world all these four variants require distinct representations. In contrast, in
the typed world these representations can overlap across types, because the
static type system will ensure one type’s variants are never confused for that
the another. Thus, types have a genuine space (saving representation) and time
(eliminating run-time checks) performance benefit for programs.
