
The Typed PLAI language differs from traditional Racket most importantly by being
statically typed. It also gives you some useful new constructs: define-type,
type-case, and test. Here’s an example of each in use. 
We can introduce new datatypes:
\note{There are additional
commands for
controlling the
output of testing,
for instance. Be
sure to read the
documentation for
the language In
DrRacket v. 5.3, go
to Help, then Help
Desk, and in the
Help Desk search
bar, type
“plai-typed”}.

(define-type MisspelledAnimal
[caml (humps : number)]
[yacc (height : number)])
You can roughly think of this as analogous to the following in Java: an abstract class
MisspelledAnimal and two concrete sub-classes caml and yacc, each of which has
one numeric constructor argument named humps and height, respectively.

In this language, we construct instances as follows:
(caml 2)
(yacc 1.9)
As the name suggests, define-type creates a type of the given name. We can use this
when, for instance, binding the above instances to names:
(define ma1 : MisspelledAnimal (caml 2))
(define ma2 : MisspelledAnimal (yacc 1.9))
In fact you don’t need these particular type declarations, because Typed PLAI will infer
types for you here and in many other cases. Thus you could just as well have written

(define ma1 (caml 2))
(define ma2 (yacc 1.9))

but we prefer to write explicit type declarations as a matter of both discipline and
comprehensibility when we return to programs later.
The type names can even be used recursively, as we will see repeatedly in this book
(for instance, section 2.4).
The language provides a pattern-matcher for use when writing expressions, such as
a function’s body:
(define (good? [ma : MisspelledAnimal]) : boolean
(type-case MisspelledAnimal ma
[caml (humps) (>= humps 2)]
[yacc (height) (> height 2.1)]))
In the expression (>= humps 2), for instance, humps is the name given to whatever
value was given as the argument to the constructor caml.
Finally, you should write test cases, ideally before you’ve defined your function,
but also afterwards to protect against accidental changes:

(test (good? ma1) #t)
(test (good? ma2) #f)
When you run the above program, the language will give you verbose output telling
you both tests passed. Read the documentation to learn how to suppress most of these
messages.
Here’s something important that is obscured above. We’ve used the same name,
humps (and height), in both the datatype definition and in the fields of the patternmatch.
This is absolutely unnecessary because the two are related by position, not
name. Thus, we could have as well written the function as
(define (good? [ma : MisspelledAnimal]) : boolean
(type-case MisspelledAnimal ma
[caml (h) (>= h 2)]
[yacc (h) (> h 2.1)]))

Because each h is only visible in the case branch in which it is introduced, the two
hs do not in fact clash. You can therefore use convention and readability to dictate
your choices. In general, it makes sense to provide a long and descriptive name when
defining the datatype (because you probably won’t use that name again), but shorter
names in the type-case because you’re likely to use use those names one or more
times.
I did just say you’re unlikely to use the field descriptors introduced in the datatype
definition, but you can. The language provides selectors to extract fields without the
need for pattern-matching: e.g., caml-humps. Sometimes, it’s much easier to use the
selector directly rather than go through the pattern-matcher. It often isn’t, as when
defining good? above, but just to be clear, let’s write it without pattern-matching:
(define (good? [ma : MisspelledAnimal]) : boolean
(cond
[(caml? ma) (>= (caml-humps ma) 2)]
[(yacc? ma) (> (yacc-height ma) 2.1)]))
9

\DoNow{
What happens if you mis-apply functions to the wrong kinds of values?
For instance, what if you give the caml constructor a string? What if you
send a number into each version of good? above?
}

