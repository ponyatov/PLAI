\secrel{Adding Functions to the Language\\
\ru{Добавление функций в язык}}\secdown

Let’s start turning this into a real programming language.
\ru{Теперь давайте превратим нашу поделку в настоящий язык программирования.}
We could add intermediate features such as conditionals,
\ru{Мы можем добавить вспомогательные фичи типа условных конструкций,}
but to do almost anything interesting
\ru{но чтобы сделать что-то интересное}
we’re going to need functions or their moral equivalent, 
\ru{нам нужны \termdef{функции}{функция} или их эквивалент,}
so let’s get to it.
\ru{так что начнем.}

\Exercise{
Add conditionals to your language.
\ru{Добавьте условные конструкции в ваш язык.}
You can either add boolean datatypes
\ru{Вы можете добавить булевый тип данных}
or, if you want to do something quicker,
\ru{или, если вы хотите сделать это побыстрее,}
add a conditional that treats \emph{0} as \term{false}
\ru{добавьте условие что \emph{0} считается \term{ложью},}
and \emph{everything else} as \term{true}.
\ru{ и не-ноль\ --- \term{истиной}.}

What are the important test cases you should write\,?\\
\ru{Какие варианты тестов вы должны написать\,?}
}

Imagine, therefore, that we’re modeling a system like Dr\racket.
\ru{Представьте что мы моделируюем систему типа Dr\racket.}
The developer defines functions in the definitions window, 
\ru{Разработчик определяет функции в окне определений,}
and uses them in the interactions window.
\ru{и использует их к интерактивном окне.}
For now, let’s assume all definitions go in the definitions window only
\ru{Предполагается что все определения вводятя \emph{только} в окне определений}
(we’ll relax this soon \ru{позже мы ослабим это требование} \ref{}),
and all expressions in the interactions window only.
\ru{а все выражения только в интерактивном окне.}
Thus, running a program simply loads definitions.
\ru{Таким образом, запуск программы просто загружает определения.}
Because our interpreter corresponds to the interactions window prompt,
\ru{Так как наш интерпретатор соответствует строке ввода интерактивного окна,}
we’ll therefore assume it is supplied with a set of definitions.
\ru{мы также предполагаем что интерпретатор укомплектован набором этих
определений.}
\note{A \emph{set} of definitions suggests \emph{no ordering}, which means,
presumably, any definition can refer to any other. That’s what I intend here,
but when you are designing your own language, be sure to think about this.}
\note{\ru{\emph{Набор} определений предполагает \emph{отсутствие
упорядочивания}, то есть любое определение может ссылаться на любое другое. Вот
что я здесь предполагаю сделать, но когда вы разрабатываете ваш собственный
язык, подумайте об этом.}}
\clearpage

\input{5_1_datarepr}
\input{5_2_growing}
\input{5_3_subst}
\input{5_4_resumed}
\input{5_5_more}
\secup
