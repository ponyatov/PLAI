\secrel{\class{Sym}: universal [sym]bolic data type\\\ru{универсальный [sym]вольный тип данных}}\secdownПрежде чем мы продолжим с парсером, нам нужно уточнить, как мы будем хранитьрезультаты разбора. В PLAI в качестве хранилища \termdef{дерева разбора}{дереворазбора} используется традиционное для \lisp-мира представление в виде списков,где \emph{первым элементом идет вершина дерева}, а в следующих элементахнаходятся поддеревья.Но если мы внимательно рассмотрим синтаксис современных main\-stream языковпрограммирования\note{и текстовых форматов данных}, и учтем что нашей цельюявляется создание метаязыка для трансформации программ, более удобным иправильным кажется использование не списков, а \termdef{атрибутныхдеревьев}{атрибутное дерево}.Вместо класса \class{ArithC} нам нужно дерево классов, наследованных от одного\term{виртуального} базового класса \class{Sym}. Это требование вытекает изжесткой типизации и отсутствия в \cpp\ поддержки \term{гетерогенных} структурданных, способных хранить в себе \emph{разнотипные} элементы. Если мы используемнабор типов\note{которые будут хранить в себе элементы нашего дерева разбора},наследованных от одного виртуального класса, мы сможем оперировать ими черезуказатели на базовый класс \class{Sym*}, и воспользоваться динамическимихранилищами из библиотеки \cpp\ STL: \class{deque<Sym*>} и\class{map<string,Sym*>}.\lstxl{hpp.hpp}{sym/head.hpp}{C++}\lstxl{cpp.cpp}{sym/head.cpp}{C++}\clearpageЛюбой элемент данных должен:\begin{description}\item[хранить свое значение и идентифицировать свой тип]\ \\\emph{универсальнымпредставлением любых данных является строка}:\lstxl{hpp.hpp}{sym/tagval.hpp}{C++}В \cpp\ есть средства идентификации класса по указателю на экземпляр (RTTI,\fn{typeid()}), и по крайней мере тип тэга должен быть \class{staticSym*}\note{указывать на экземпляр \class{Clazz::Sym *symbol, *number,*string,..} т.е. на элемент данных типа ``класс'', существующий внутри нашейDLR; собственно на текущий момент нам от него нужно только название класса} илихотя бы \class{static string}, но для максимального \emph{упрощения кода} мыиспользуем просто строку.\item[конструктор]\ \\создает элемент данных по паре тэг:значение <T:V>\lstxl{hpp.hpp}{sym/constv.hpp}{C++}\item[лексемы] (=\term{токены} =\term{терминалы})\ \\должны иметь конструктор изстроки, выделенной лексером\lstxl{hpp.hpp}{sym/constoc.hpp}{C++}\lstxl{cpp.cpp}{sym/constv.cpp}{C++}\clearpage\item[базовый класс]\ \\должен иметь \emph{по крайней мере одну} виртуальнуюфункцию. Классически для этого рекомендуется использовать виртуальныйдеструктор. Позже \ref{symgc} при реализации управления памятью мы так исделаем, а пока воспользуемся следущим требованием:\item[выводить себя в текстовом представлении]\ \\для отладки или трансляции\lstxl{hpp.hpp}{sym/dump.hpp}{C++}\lstxl{cpp.cpp}{sym/dump.cpp}{C++}\item[хранить в себе вложенные элементы]\ \\\emph{самое важное для наших целейтребование}. \item[1) с доступом по целочисленному индексу] (аналог массивов)\ \\простейший случай, типичное решение для реализации деревьев с \emph{любым}количеством ветвей, для реализации применим C++ шаблонный класс STL\class{deque<Sym*>}. Каждый \class{Sym}-объект может выступатьв роли \term{массива с доступом на целому индексу}, \term{очереди} и\term{стека}.\lstxl{hpp.hpp}{sym/nest.hpp}{C++}\lstxl{cpp.cpp}{sym/nest.cpp}{C++}\item[2) с доступом по имени]\ \\необходимо для реализации таблицсимволов\note{подробно ср\'{е}ды и применение lookup таблиц рассмотрено в\ref{env}}, адресации полей классов, хранения других атрибутов\note{напримерполе \var{doc} для документирования аналогично \var{\_\_doc\_\_} в \py}, в общемреализации \term{атрибутного} дерева.\lstxl{hpp.hpp}{sym/lookup.hpp}{C++}\item[выводить себя в текстовом виде в виде дерева]\ \\так как предполается чтомы работаем исключительно с атрибутными деревьями, необходимо наличие средствапросмотра не только содержимого, но и структуры любого элемента данных.Мы должны иметь возможность визуально определять вложенность, а в идеале\ ---иметь возможность копировать полученный \termdef{дамп}{дамп} в исходный код ввиде, который распознает парсер\note{сейчас это потребует значительногоусложнения синтаксиса и кода парсера, поэтому реализацию\termdef{bootstrap}{bootstrap}-дампа пока отложим}.\lstxl{hpp.hpp}{sym/dumptree.hpp}{C++}\begin{tabular}{l l}\fn{head()} & вывод заголовка \\\fn{pad(int)} & отбивка табуляциями каждой строки дампа,\\& определяется вложенностью \var{depth}\\\fn{dump(depth++)} & \emph{рекурсивный} дамп дерева \\\end{tabular}\lstxl{cpp.cpp}{sym/dumptree.cpp}{C++}Итак, у нас есть универсальный базовый тип для представления атрибутныхдеревьев. Но для практического применения желательно добавить пару производных типов для представления чисел и операторов.Через наследование \class{Sym} мы можем определять новые элементы данных,отличающиеся особенным поведением\note{например \class{оператор}ы могут уметьвычислять математические функции от своих вложенных аргументов}, или\term{обертывать} классы\note{элементы GUI, интерфейсы СУБД, сетевыесоединения,\ldots} и произвольные \emph{библиотеки}, не связанные с ядром DLR.   \end{description}\input{sym/num}\input{sym/wrap}\secup