\secrel{$\oplus$ \class{Sym}: \ru{универсальный тип данных}}Прежде чем мы продолжим с парсером, нам нужно уточнить, как мыбудем хранить результаты разбора. Выше в качестве хранилища \termdef{дереваразбора}{дерево разбора} используются традиционное для \lisp-мира представлениев виде списков, где \emph{первым элементом идет вершина дерева}, а в следующихэлементах находятся поддеревья.Но если мы внимательно рассмотрим синтаксис современных main\-stream языковпрограммирования\note{и текстовых форматов данных}, и учтем что нашей цельюявляется создание метаязыка для трансформации программ, более удобным иправильным кажется использование не списков, а \termdef{атрибутныхдеревьев}{атрибутное дерево}.Вместо класса \class{ArithC} нам нужно дерево классов, наследованных от одного\term{виртуального} базового класса \class{Sym}. Это требование вытекает изжесткой типизации и отсутствии в \cpp\ поддержки \term{гетерогенных} структурданных, способных хранить в себе \emph{разнотипные} элементы. Если мыиспользуем набор типов\note{которые будут хранить в себе элементы нашего дереваразбора}, наследованных от одного виртуального класса, мы сможем оперировать имичерез указатели на базовый класс \class{Sym*}, и воспользоваться динамическимихранилищами из библиотеки \cpp\ STL: \class{vector<Sym*>} и\class{map<string,Sym*>}.\lstxl{hpp.hpp}{2/6/sym/head.hpp}{C++}\lstxl{cpp.cpp}{2/6/sym/head.cpp}{C++}\clearpageЛюбой элемент данных должен:\begin{description}\item[хранить свое значение и идентифицировать свой тип]\ \\\emph{универсальнымпредставлением любых данных является строка}:\lstxl{hpp.hpp}{2/6/sym/tagval.hpp}{C++}В \cpp\ есть средства идентификации класса по указателю на экземпляр (RTTI,\fn{typeid()}), и по крайней мере тип тэга должен быть \class{staticSym*}\note{указывать на экземпляр \class{Clazz::Sym *symbol, *number,*string,..} т.е. на элемент данных типа ``класс'', существующий внутри нашейDLR; собственно на текущий момент нам от него нужно только название класса} илихотя бы \class{static string}, но для максимального \emph{упрощения кода} мыиспользуем просто строку.\item[конструктор]\ \\создает элемент данных по паре тэг:значение <T:V>\lstxl{hpp.hpp}{2/6/sym/constv.hpp}{C++}\item[лексемы] (=\term{токены} =\term{терминалы})\ \\должны иметь конструктор изстроки, выделенной лексером\lstxl{hpp.hpp}{2/6/sym/constoc.hpp}{C++}\lstxl{cpp.cpp}{2/6/sym/constv.cpp}{C++}\clearpage\item[базовый класс]\ \\должен иметь \emph{по крайней мере} одну виртуальнуюфункцию\item[выводить себя в текстовом представлении]\ \\для отладки или трансляции\lstxl{hpp.hpp}{2/6/sym/dump.hpp}{C++}\lstxl{cpp.cpp}{2/6/sym/dump.cpp}{C++}\end{description}